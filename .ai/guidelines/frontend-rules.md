# Frontend Architecture & Code Rules

## Core Principle

Pages compose. Components render. Hooks contain logic. shadcn provides primitives.

## Type Safety

All data sent from the backend to the frontend must be typed via `spatie/laravel-data` Data classes, with TypeScript types auto-generated by `spatie/laravel-typescript-transformer`. Never manually write TypeScript types for backend data — use the generated types. Hand-written types are only for frontend-only concerns (component props, UI state, navigation).

### Inertia Page Props

Every `Inertia::render()` call that passes data MUST use a Data class with the `#[TypeScript]` attribute — never a raw array. This ensures page props have generated TypeScript types.

```php
// Backend: Data class with #[TypeScript] attribute
#[TypeScript]
class ProfilePageData extends Data
{
    public function __construct(
        public bool $mustVerifyEmail,
        public ?string $status = null,
    ) {}
}

// Backend: Controller passes Data class to Inertia::render()
public function edit(Request $request): Response
{
    return Inertia::render('settings/profile', new ProfilePageData(
        mustVerifyEmail: $request->user() instanceof MustVerifyEmail,
        status: $request->session()->get('status'),
    ));
}
```

```tsx
// Frontend: Use the generated type for page component props
type Props = App.Features.Settings.Data.ProfilePageData;

export default function Profile({ mustVerifyEmail, status }: Props) {
    // ...
}
```

Pages that receive no props do not need a Data class.

## Component Architecture

Page components must be skinny: compose a layout, set route metadata (`Head`, breadcrumbs), and render feature components. No form markup, hooks, or business logic directly in page components.

Components own their local state. Using `useState`, `useEffect`, etc. inside a component is fine.

Extract reusable logic to custom hooks in `hooks/`. If two or more components share the same logic, or if logic is complex enough to test independently, it belongs in a hook.

Always check `components/` and `components/ui/` for existing components before creating new ones.

## shadcn/ui

This project uses [shadcn/ui](https://ui.shadcn.com/) (new-york style, lucide icons).

Before building a custom component, check if shadcn offers one: `npx shadcn@latest add <component>`. shadcn components live in `components/ui/` and should not be modified unless truly necessary. Wrap them for custom behavior.

Use shadcn design tokens (`bg-background`, `text-foreground`, `border-border`, `text-muted-foreground`, etc.) over raw Tailwind color classes.

## File Naming

- Files: `kebab-case.tsx` (e.g., `delete-user.tsx`, `two-factor-setup-modal.tsx`).
- Component exports: `PascalCase` (e.g., `export default function DeleteUser()`).
- Hooks: `use-` prefix, kebab-case files (e.g., `use-clipboard.ts`), camelCase export (e.g., `useClipboard`).
- Types: `PascalCase` (e.g., `AppLayoutProps`, `BreadcrumbItem`).

## Tailwind & Styling

- Use shadcn design tokens and CSS variables over raw Tailwind colors (e.g., `bg-primary` not `bg-blue-500`).
- Utility classes directly in JSX. No separate CSS files for components.
- Use the `cn()` utility from `lib/utils` for conditional class merging.
- Avoid arbitrary values (`bg-[#123456]`) when a design token exists.

## Node Commands

Run `npm` and `npx` directly on the host machine — not through the Sail container. For example: `npm run dev`, `npx tsc --noEmit`, `npx shadcn@latest add <component>`.

## Code Quality Checks

After completing any task that involves frontend code, you MUST run the following scripts in order:

1. `npm run lint` — Runs ESLint with auto-fix.
2. `npm run format` — Formats code with Prettier.
3. `npm run types` — Runs TypeScript type checking.

All three must pass cleanly. Fix any issues they surface before considering the task complete.
